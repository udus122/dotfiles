# Kiro 仕様書駆動開発

## 仕様書の構成

本プロジェクトでは、以下の3つのファイルで仕様を管理します。

### requirements.md
EARS構文（Easy Approach to Requirements Syntax）を用いて要求定義を記述します。

**EARS構文パターン:**
- **通常要件**: システムは〜しなければならない
- **条件付き要件**: [条件]の場合、システムは〜しなければならない  
- **イベント駆動要件**: [イベント]が発生した場合、システムは〜しなければならない
- **状態依存要件**: システムが[状態]にある限り、〜しなければならない
- **オプション要件**: 必要に応じて、システムは〜できる

### design.md
システムの設計とアーキテクチャを記述します。
- コンポーネント構成
- データフロー
- インターフェース定義
- 技術選定の根拠

### tasks.md
実装計画を具体的なタスクに分解したリストを記述します。
- タスクの優先度
- 依存関係
- 完了条件
- 実装状況の追跡

## ディレクトリ構造

```
.kiro/
├── specs/
│   ├── {機能名1}/
│   │   ├── requirements.md
│   │   ├── design.md
│   │   └── tasks.md
│   └── {機能名2}/
│       ├── requirements.md
│       ├── design.md
│       └── tasks.md
└── steering/
    ├── product.md      # 製品概要
    ├── tech.md         # 技術スタック
    ├── structure.md    # プロジェクト構造
    └── {カスタム}.md   # プロジェクト固有のガイドライン
```

## Steering（プロジェクト永続知識）

Steeringは、プロジェクトに関する永続的な知識を `.kiro/steering/` に配置することで、一貫性のある開発を実現します。

### デフォルトSteering ファイル

**product.md（製品概要）**
- 製品の目的と価値提案
- ターゲットユーザー
- 主要機能
- ビジネス目標

**tech.md（技術スタック）**
- 使用フレームワークとライブラリ
- 開発ツール
- 技術的制約
- パフォーマンス要件

**structure.md（プロジェクト構造）**
- ファイル構成
- 命名規則
- インポートパターン
- アーキテクチャ決定

### カスタムSteering ファイル

プロジェクトの需要に応じて追加のSteering ファイルを作成できます：

**api-standards.md（API規約）**
```yaml
---
inclusion: fileMatch
fileMatchPattern: "app/api/**/*"
---
```
- RESTful設計規則
- エラーレスポンス形式
- 認証フロー
- バージョニング戦略

**testing-standards.md（テスト規約）**
```yaml
---
inclusion: fileMatch
fileMatchPattern: "**/*.test.*"
---
```
- ユニットテストパターン
- 統合テスト戦略
- モッキング方針
- カバレッジ目標

**security-policies.md（セキュリティガイドライン）**
```yaml
---
inclusion: always
---
```
- 認証要件
- データ検証ルール
- 入力サニタイゼーション
- 脆弱性防止策

### インクルージョンモード

1. **always（常に含める）**: すべての作業で参照される基本的なガイドライン
2. **fileMatch（条件付き）**: 特定のファイルパターンにマッチした場合のみ参照
3. **manual（手動）**: 必要に応じて明示的に参照（#steering-file-name）

### ファイル参照

既存ファイルへの参照を含める場合：
```markdown
#[[file:api/openapi.yaml]]
#[[file:components/ui/button.tsx]]
#[[file:.env.example]]
```

## 仕様書のイテレーション

仕様書は継続的な改善を前提としています：

### 要件の更新
1. `requirements.md` を直接編集
2. または仕様セッションで新要件を追加指示

### 設計の更新
1. `design.md` を開いて「Refine」を実行
2. 要件変更に応じて設計とタスクリストが自動更新

### タスクの更新
1. `tasks.md` で「Update tasks」を実行
2. 新要件に対応する新タスクが生成
3. 既に実装済みのタスクは自動的にマーク

## 複数仕様書の管理

単一リポジトリ内で複数の仕様書を管理することを推奨します：

**ECサイトの例：**
```
.kiro/specs/
├── user-authentication/    # ログイン、サインアップ、パスワードリセット
├── product-catalog/         # 商品一覧、検索、フィルタリング
├── shopping-cart/          # カート追加、数量更新、チェックアウト
├── payment-processing/     # 決済ゲートウェイ連携、注文確認
└── admin-dashboard/        # 商品管理、ユーザー分析
```

**メリット：**
- 機能ごとの独立した作業が可能
- 管理しやすい適切なサイズの仕様書
- 特定機能への集中的なイテレーション
- チームメンバー間での並行作業

## タスク実行のベストプラクティス

### 段階的実行（推奨）
各タスクを個別に実行し、品質を確認しながら進める

### 一括実行（非推奨）
`Execute all tasks in the spec` で全タスクを一度に実行可能だが、品質管理が困難

### 実装済みタスクの処理
1. `tasks.md` で「Update tasks」をクリック
2. または「Check which tasks are already complete」を実行
3. 実装済みタスクが自動的にマークされる

## 仕様書作成の原則

1. **明確性**: 曖昧な表現を避け、具体的に記述する
2. **追跡可能性**: 要求から設計、タスクまでの関連を明確にする
3. **検証可能性**: 各要求の達成条件を明確に定義する
4. **保守性**: 変更が容易になるよう構造化する
5. **反復性**: 継続的な改善を前提とした柔軟な構造

## チーム共有のベストプラクティス

### バージョン管理
- 仕様書をGitリポジトリで管理
- コードと仕様書を同じリポジトリに配置
- 要件と実装の関連性を維持

### クロスチーム共有
- 中央仕様書リポジトリの作成
- Gitサブモジュールまたはパッケージ参照の活用
- クロスリポジトリワークフローの実装

### 既存要件のインポート
- JIRA、Confluence等からの手動インポート
- MCPサーバー経由での直接接続（STDIO対応の場合）
- 既存ドキュメント（PRD、PRFAQなど）からの仕様生成

## セキュリティ上の注意

- APIキー、パスワード等の認証情報は記載しない
- 環境固有の設定は環境変数で管理することを前提とする
- 機密性の高い業務ロジックは抽象化して記述する
- Steeringファイルはコードベースの一部として扱う
