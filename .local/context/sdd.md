# 仕様書駆動開発（Spec-Driven Development）

## 概要

仕様書駆動開発は、概念的な製品要件と技術的な実装詳細のギャップを埋め、開発の手戻りを削減するアプローチです。明確に構造化された仕様書を作成することで、プロダクトチームとエンジニアリングチーム間の認識を一致させます。

## ワークフロー

### 開発フェーズ
1. フェーズ0: ステアリング（オプション）
2. フェーズ1: 要求定義（Requirements）
3. フェーズ2: 技術設計（Design）
4. フェーズ3: 実装計画（Implementation Planning）
5. フェーズ4: 実行（Execution）

各フェーズは順次実行し、完了確認後に次のフェーズに進む。継続的な改善とフィードバックを全フェーズで実施。

### 実行順序の厳守
- 作業は必ず Steering（必要な場合のみ） → `requirements.md` → `design.md` → `tasks.md` → 実装（Execution Phase）の順で進め、各ステップの完了を確認してから次に進むこと。

#### フェーズ0: ステアリング(任意)
- `/sdd:steering`で実行: steeringファイルを作成/更新する

Note: 新機能開発や小さな追加機能においてはオプションフェーズです。大きな機能追加やプロジェクト開始時に推奨されます。

### フェーズ1: 要求定義（Requirements Phase）
- ユーザーストーリーの収集
- EARS記法での構造化
- 受け入れ条件の定義
- 優先順位付け

### フェーズ2: 技術設計（Design Phase）
- アーキテクチャの文書化
- コンポーネント設計
- インターフェース定義
- 技術的考慮事項の整理

### フェーズ3: 実装計画（Implementation Planning）
- タスクへの分解
- 依存関係の明確化
- 工数見積もり
- リソース割り当て

### フェーズ4: 実行（Execution Phase）
- タスクの実行
- 進捗の追跡
- 仕様の更新と改善
- 完了確認

## 作成物

### メタデータ(フロントマター)
各仕様書ファイルには、以下のYAML形式のフロントマターを含めます

```yaml
---
status: draft  # draft | approved | rejected
created_at: 2025-01-15
updated_at: 2025-01-20
---
```

#### ステータス(`status`)

- draft: 初期作成段階、レビュー待ち
- approved: レビュー完了、実装可能
- rejected: 却下、再検討が必要

#### タイムスタンプ

- created_at: 仕様書の初回作成日（YYYY-MM-DD形式）
- updated_at: 最終更新日（YYYY-MM-DD形式）

### 1. requirements.md - 要求定義
ユーザーストーリーと受け入れ条件をEARS記法で記述します。

EARS記法（Easy Approach to Requirements Syntax）
構造化された形式で明確かつテスト可能な要件を記述：

主要なEARSパターン（英語構文を使用、内容は日本語）:
- WHEN [イベント/条件] THEN [システム/主体] SHALL [応答]
- IF [前提条件/状態] THEN [システム/主体] SHALL [応答]
- WHILE [継続条件] THE [システム/主体] SHALL [継続的な振る舞い]
- WHERE [場所/コンテキスト/トリガー] THE [システム/主体] SHALL [コンテキストにおける振る舞い]

例：
```markdown
WHEN ユーザーが無効なデータを含むフォームを送信した場合
THEN システム SHALL 該当フィールドの隣に検証エラーを表示する
```

ドキュメント構造:
- アウトカムマッピング: 要件IDとrequests.mdのアウトカムの紐付け
- 機能要件: REQ-1, REQ-2, ... で管理
- 非機能要件: REQ-3, REQ-4, ... で管理（セクションで区別）
- 各要件に含む項目:
  - 目的（ユーザーストーリー）
  - 受け入れ基準（EARS記法）
  - 検証方法
- 完全性チェック: 正常系・異常系・境界条件の網羅確認

4つの利点:
1. Clarity（明確性）: 曖昧さのない理解しやすい要件、要件ID体系での追跡
2. Testability（テスト可能性）: 検証方法を明記し、テストケースへの変換が容易
3. Traceability（追跡可能性）: アウトカムマッピングで要件と目的を紐付け
4. Completeness（完全性）: チェックリストで条件・動作の網羅を確認

### 2. design.md - 技術設計
requests.mdとrequirements.mdをインプットとして、技術的な設計を文書化します。

#### 推奨構成

必須セクション:
1. 目的・ゴール: 数文で「何を実現するか」を定義
2. 背景: 数段落で実装理由・前提知識・制約を説明
3. 設計の概要: 重要な部分を簡略化して説明
   - 実装の基本的なアイディア
   - 簡略化した構成図（Mermaid）
   - 重要な要素の列挙
4. 詳細設計: 要素ごと・見る角度ごとに
   - モジュール/コンポーネントの説明
   - データモデル
   - API設計（該当する場合）
   - データフロー・シーケンス図

条件付きセクション（必要に応じて）:
- セキュリティの考慮事項
- パフォーマンスとスケーラビリティ
- 移行戦略
- エラー処理
- テスト戦略

#### 作成の原則

シンプルさを保つ:
- 細かく書きすぎない: 重要でない要素は省略
- 特に注意すべきことに焦点を当てる
- 簡略化した図を使用（詳細すぎるクラス図は避ける）

構造化された説明:
- 目的・ゴールを最初に明確化（数文以内）
- 背景は簡潔に（必要なら別文書へのリンク）
- 設計の概要で全体像を示してから詳細へ

ビジュアル重視:
- Mermaid図を積極的に使用
- モジュール構成図・クラス図は簡略化
- データフロー・シーケンス図で動的な側面を表現

レビュー最適化:
- 重要な技術的決定を目立つ位置に配置
- 実装の基本的なアイディアを明示
- 解決すべき技術課題とその解決法を明記

### 3. tasks.md - 実装計画
詳細な実装計画を個別の追跡可能なタスクとサブタスクに分解します。

タスク構成要素：
- タスク番号とタイトル
- 明確な説明
- 期待される成果
- 依存関係
- 推定工数
- 優先度
- 実装状態（未着手/進行中/完了）

- 1-3時間単位のタスクに分解
- 順序: データモデル → ビジネスロジック → インターフェース → テスト
- design.md対応を明記
- チェックボックス形式: `- [ ] タスク内容`

### 仕様書の

## ディレクトリ構造

```
.sdd/
├── specs/
│   ├── {機能名1}/
│   │   ├── requirements.md  # 要求定義
│   │   ├── design.md        # 技術設計
│   │   └── tasks.md         # 実装タスク
│   └── {機能名2}/
│       ├── requirements.md
│       ├── design.md
│       └── tasks.md
└── steering/
    ├── product.md           # 製品概要
    ├── tech.md              # 技術スタック
    ├── structure.md         # プロジェクト構造
    └── {カスタム}.md         # プロジェクト固有ガイドライン
```

## 仕様書の継続的改善

### 要件の更新
- requirements.md を直接編集または仕様セッションで更新
- 新しい要件の追加、既存要件の修正

### 設計の更新
- design.md を更新して要件変更を反映
- アーキテクチャの改善、最適化

### タスクの更新
- 完了タスクのマーキング
- 新規タスクの追加
- 依存関係の調整

### フィードバックループ
- 実装中に発見した課題を仕様にフィードバック
- チームレビューを通じた改善
- 実装経験を基にした最適化

## ベストプラクティス

### 仕様書作成の原則
1. 明確性 - 曖昧な表現を避け、具体的に記述
2. 追跡可能性 - 要求から実装まで追跡可能
3. 検証可能性 - 達成条件が明確
4. 保守性 - 変更が容易な構造
5. 反復性 - 継続的改善を前提

### 複数機能の管理
- 機能ごとに独立した仕様書を作成
- 適切な粒度での分割（1機能 = 1-2週間の作業量）
- 依存関係の明確化

## セキュリティガイドライン

- 認証情報や機密データは仕様書に含めない
- 環境固有の設定は環境変数で管理
- 機密性の高いロジックは抽象化して記述
