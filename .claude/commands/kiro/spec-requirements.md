---
description: 仕様の包括的な要件を生成
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
---

# 要件生成

機能の包括的な要件を生成: **$ARGUMENTS**

## コンテキスト検証

### ステアリングコンテキスト

- アーキテクチャコンテキスト: @.kiro/steering/structure.md
- 技術的制約: @.kiro/steering/tech.md
- プロダクトコンテキスト: @.kiro/steering/product.md

### 既存の仕様コンテキスト

- 現在の仕様ディレクトリ: !`ls -la .kiro/specs/$ARGUMENTS/`
- 現在の要件: @.kiro/specs/$ARGUMENTS/requirements.md
- 仕様メタデータ: @.kiro/specs/$ARGUMENTS/spec.json

## タスク: 初期要件の生成

機能アイデアに基づいてEARS形式で初期要件セットを生成し、完全かつ正確になるまでユーザーと反復して洗練します。

このフェーズではコード探索に焦点を当てないでください。代わりに、後で設計に変換される要件の作成に集中してください。

### 要件生成ガイドライン

1. コア機能に焦点: ユーザーのアイデアから必須機能を開始
2. EARS形式を使用: すべての受け入れ基準は適切なEARS構文を使用する必要がある
3. 連続質問をしない: 最初に初期バージョンを生成し、ユーザーフィードバックに基づいて反復
4. 管理可能に保つ: ユーザーレビューを通じて拡張できるしっかりした基盤を作成

### 1. EARS形式の要件

**EARS（Easy Approach to Requirements Syntax）**は受け入れ基準の必須形式です:

主要なEARSパターン:
- **WHEN** [イベント/条件] **THEN** [システム] **SHALL** [応答]
- **IF** [前提条件/状態] **THEN** [システム] **SHALL** [応答]
- **WHILE** [継続条件] **THE SYSTEM SHALL** [継続的な動作]
- **WHERE** [場所/コンテキスト] **THE SYSTEM SHALL** [コンテキストに応じた動作]

組み合わせパターン:
- **WHEN** [イベント] **AND** [追加条件] **THEN** [システム] **SHALL** [応答]
- **IF** [条件] **AND** [追加条件] **THEN** [システム] **SHALL** [応答]

### 2. 要件の階層と粒度

明確な階層で要件を構造化:

```
# 要件ドキュメント
├── 導入（機能概要）
├── 要件
│   ├── 要件1（主要機能領域）
│   │   ├── ユーザーストーリー（高レベルのニーズ）
│   │   └── 受け入れ基準（詳細なEARS）
│   │       ├── ハッピーパスシナリオ
│   │       ├── エッジケースとエラー条件
│   │       ├── ユーザーエクスペリエンスの考慮事項
│   │       └── 技術的制約
│   ├── 要件2（次の機能領域）
│   └── ...
```

粒度ガイドライン:
- 高レベル要件: 機能アイデアからの主要な機能領域
- ユーザーストーリー: 各要件領域内の特定のユーザーニーズ  
- 受け入れ基準: EARS形式を使用したテスト可能な条件

### 3. 要件ドキュメント構造

spec.jsonで指定された言語でrequirements.mdを生成（`@.kiro/specs/$ARGUMENTS/spec.json`の"language"フィールドを確認）:

```markdown
# 要件ドキュメント

## 導入
[機能とそのビジネス価値を要約した明確な導入]

## 要件

### 要件1: [主要機能領域]
ユーザーストーリー: [ロール]として、[機能]が欲しい。なぜなら[利益]が得られるから

#### 受け入れ基準
このセクションにEARS要件を記載

1. WHEN [イベント] THEN [システム] SHALL [応答]
2. IF [前提条件] THEN [システム] SHALL [応答]
3. WHILE [継続条件] THE SYSTEM SHALL [継続的動作]
4. WHERE [場所/コンテキスト] THE SYSTEM SHALL [コンテキスト動作]

### 要件2: [次の主要機能領域]
ユーザーストーリー: [ロール]として、[機能]が欲しい。なぜなら[利益]が得られるから

1. WHEN [イベント] THEN [システム] SHALL [応答]
2. WHEN [イベント] AND [条件] THEN [システム] SHALL [応答]

### 要件3: [追加の主要領域]
[すべての主要機能領域についてパターンを継続]
```

### 4. メタデータの更新
spec.jsonを以下で更新:
```json
{
  "phase": "requirements-generated",
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": false
    }
  },
  "updated_at": "現在のタイムスタンプ"
}
```

### 5. ドキュメント生成のみ

要件ドキュメントの内容のみを生成します。実際のドキュメントファイルにレビューや承認の指示を含めないでください。

---

## インタラクティブ承認利用可能（ドキュメントに含まれません）

以下はClaude Codeの会話専用 - 生成されたドキュメントには含まれません:

### 次のフェーズはインタラクティブ承認を使用

requirements.md生成後、次のフェーズ（`/kiro:spec-design $ARGUMENTS`）はインタラクティブ承認を使用:

次のインタラクション:
```
/kiro:spec-design 機能名
# → "requirements.mdをレビューしましたか？ [y/N]"
# → 'y'の場合: 自動承認 + 設計生成
# → 'N'の場合: 停止してまずレビューを要求
```

### インタラクティブ承認のメリット

1. 合理化されたワークフロー: spec.jsonの手動編集不要
2. レビュー強制: 人間によるレビュー確認が依然必要
3. 即座に進行: 承認されたフェーズは自動的に進行
4. 安全性の維持: 'N'応答は適切なレビューのために実行を停止

### レビューチェックリスト（ユーザー参照用）:

- [ ] 要件が明確で完全
- [ ] ユーザーストーリーが必要なすべての機能をカバー
- [ ] 受け入れ基準がテスト可能
- [ ] 要件がプロジェクト目標と整合

### 従来の手動承認も利用可能

必要な場合、`.kiro/specs/$ARGUMENTS/spec.json`を更新して手動承認することも可能:
```json
{
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true
    }
  },
  "phase": "requirements-approved"
}
```

**推奨**: より良いユーザーエクスペリエンスのために`/kiro:spec-design $ARGUMENTS`のインタラクティブ承認を使用。

## 指示事項

1. spec.jsonで言語を確認 - メタデータで指定された言語を使用
2. 最初に連続した質問をしないで、機能アイデアに基づいて初期要件を生成
3. EARS形式を適用 - すべての受け入れ基準に適切なEARS構文パターンを使用
4. コア機能に焦点 - 必須機能とユーザーワークフローから開始
5. 明確に構造化 - 関連機能を論理的な要件領域にグループ化
6. 要件をテスト可能にする - 各受け入れ基準は検証可能であるべき
7. 完了時にトラッキングメタデータを更新

機能アイデアからのコア機能に焦点を当てて、設計フェーズのためのしっかりした基盤を提供する要件を生成します。
think
