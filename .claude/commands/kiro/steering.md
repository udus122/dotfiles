---
description: プロジェクト状態に基づいてKiroステアリングドキュメントをインテリジェントに作成または更新
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Glob, Grep, LS
---

# Kiroステアリング管理

仕様駆動開発のための正確なプロジェクト知識を維持するため、`.kiro/steering/`にステアリングドキュメントをインテリジェントに作成または更新します。このコマンドは既存のドキュメントを検出し、適切に処理します。

## 既存ファイルの確認

### 現在のステアリングドキュメントステータス
- プロダクト概要: !`[ -f ".kiro/steering/product.md" ] && echo "✅ EXISTS - カスタムコンテンツを保持して更新します" || echo "📝 未発見 - 新規作成します"`
- 技術スタック: !`[ -f ".kiro/steering/tech.md" ] && echo "✅ EXISTS - カスタムコンテンツを保持して更新します" || echo "📝 未発見 - 新規作成します"`
- プロジェクト構造: !`[ -f ".kiro/steering/structure.md" ] && echo "✅ EXISTS - カスタムコンテンツを保持して更新します" || echo "📝 未発見 - 新規作成します"`
- カスタムステアリングファイル: !`if [ -d ".kiro/steering" ]; then count=$(find .kiro/steering -maxdepth 1 -type f -name '*.md' ! -name 'product.md' ! -name 'tech.md' ! -name 'structure.md' | grep -c .); if [ "$count" -gt 0 ]; then echo "🔧 $count個のカスタムファイル発見 - 保持します"; else echo "📋 No custom files"; fi; else echo "📋 まだステアリングディレクトリがありません"; fi`

## プロジェクト分析

### 現在のプロジェクト状態
- プロジェクトファイル: !`find . -path ./node_modules -prune -o -path ./.git -prune -o -path ./dist -prune -o -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" -o -name "*.java" -o -name "*.go" -o -name "*.rs" \) -print 2>/dev/null || echo "ソースファイルが見つかりません"`
- 設定ファイル: !`find . -maxdepth 3 \( -name "package.json" -o -name "requirements.txt" -o -name "pom.xml" -o -name "Cargo.toml" -o -name "go.mod" -o -name "pyproject.toml" -o -name "tsconfig.json" \) 2>/dev/null || echo "設定ファイルが見つかりません"`
- ドキュメント: !`find . -maxdepth 3 -path ./node_modules -prune -o -path ./.git -prune -o -path ./.kiro -prune -o \( -name "README*" -o -name "CHANGELOG*" -o -name "LICENSE*" -o -name "*.md" \) -print 2>/dev/null || echo "ドキュメントファイルが見つかりません"`

### 最近の変更（更新時）

- 最後のステアリング更新: !`git log -1 --oneline -- .kiro/steering/ 2>/dev/null || echo "過去のステアリングコミットなし"`
- 最後のステアリング更新以降のコミット: !`LAST_COMMIT=$(git log -1 --format=%H -- .kiro/steering/ 2>/dev/null); if [ -n "$LAST_COMMIT" ]; then git log --oneline ${LAST_COMMIT}..HEAD --max-count=20 2>/dev/null || echo "Gitリポジトリではありません"; else echo "過去のステアリング更新が見つかりません"; fi`
- 作業ツリーステータス: !`git status --porcelain 2>/dev/null || echo "Gitリポジトリではありません"`

### 既存のドキュメント

- メインREADME: @README.md
- パッケージ設定: @package.json
- Python要件: @requirements.txt
- TypeScript設定: @tsconfig.json
- プロジェクトドキュメント: @docs/

## スマート更新戦略

上記の既存ファイルチェックに基づいて、このコマンドは以下を実行します:

### 新規ファイルの場合（"📝 未発見"表示時）:

プロジェクトのすべての側面をカバーする包括的な初期コンテンツを生成。

### 既存ファイルの場合（"✅ EXISTS"表示時）:

1. ユーザーカスタマイズを保持 - 手動編集やカスタムセクション
2. 事実情報を更新 - 依存関係、ファイル構造、コマンド
3. 新セクションを追加 - 重要な新機能が存在する場合のみ
4. 非推奨コンテンツをマーク - 削除ではなく
5. フォーマットを維持 - 既存スタイルとの一貫性を保つ

## コアステアリングファイルのインクルージョンモード

3つのコアステアリングファイル（product.md、tech.md、structure.md）は**常に含める**よう設計されています - 一貫したプロジェクトコンテキストを提供するため、すべてのAIインタラクションでロードされます。

### インクルージョンモードの理解

- 常に含める（コアファイルのデフォルト）: すべてのインタラクションでロード - 一貫したプロジェクト知識を確保
- 条件付き: マッチするファイルパターンで作業する時のみロード（主にカスタムステアリング用）  
- 手動: @filename構文でオンデマンド参照（特定コンテキスト用）

### コアファイル戦略

- `product.md`: 常に - すべての開発決定に必要なビジネスコンテキスト
- `tech.md`: 常に - 技術的制約はすべてのコード生成に影響
- `structure.md`: 常に - アーキテクチャ決定はすべてのファイル組織に影響

## タスク: ステアリングドキュメントの作成または更新

### 1. プロダクト概要 (`product.md`)

#### 新規ファイルの場合:

以下を含む包括的なプロダクト概要を生成:
- プロダクト概要: プロダクトが何であるかの簡潔な説明
- コア機能: 主要な機能の箇条書きリスト
- ターゲットユースケース: プロダクトが対処する具体的なシナリオ
- 主要な価値提案: ユニークな利点と差別化要因

#### 既存ファイルの場合:

以下がある場合のみ更新:
- プロダクトに追加された新機能
- 削除された機能または非推奨機能
- 変更されたユースケースまたはターゲットオーディエンス
- 更新された価値提案または利点

### 2. 技術スタック (`tech.md`)

#### 新規ファイルの場合:

技術的な概観を完全に文書化する:
- アーキテクチャ: 高レベルシステム設計
- フロントエンド: フレームワーク、ライブラリ、ビルドツール（該当する場合）
- バックエンド: 言語、フレームワーク、サーバー技術（該当する場合）
- 開発環境: 必要なツールとセットアップ
- 一般的なコマンド: よく使用する開発コマンド
- 環境変数: 主要な設定変数
- ポート設定: サービスで使用される標準ポート

#### 既存ファイルの場合:

以下の変更を確認:
- パッケージマネージャー経由で追加された新しい依存関係
- 削除されたライブラリまたはフレームワーク
- 主要な依存関係のバージョンアップグレード
- 新しい開発ツールまたはビルドプロセス
- 変更された環境変数または設定
- 変更されたポート割り当てまたはサービスアーキテクチャ

### 3. プロジェクト構造 (`structure.md`)

#### 新規ファイルの場合:

コードベースの組織を概説:
- ルートディレクトリ構成: 説明付きのトップレベル構造
- サブディレクトリ構造: 主要ディレクトリの詳細分解
- コード組織パターン: コードの構造化方法
- ファイル命名規則: ファイルとディレクトリの命名標準
- インポート組織: インポート/依存関係の組織方法
- 主要アーキテクチャ原則: コア設計決定とパターン

#### 既存ファイルの場合:

以下の変更を探す:
- 新しいディレクトリまたは大規模な再組織
- 変更されたファイル組織パターン
- 新しいまたは変更された命名規則
- 更新されたアーキテクチャパターンまたは原則
- リファクタリングされたコード構造またはモジュール境界

### 4. カスタムステアリングファイル

カスタムステアリングファイルが存在する場合:
- 保持 - 特に古くなっていない限り変更しない
- 関連性を確認 - 削除された機能を参照している場合は注意
- 新しいカスタムファイルを提案 - 新しい専門領域が出現した場合

## 指示事項

1. `.kiro/steering/`ディレクトリを作成（存在しない場合）
2. 作成または更新モードを決定するために既存ファイルを確認
3. ネイティブツール（Glob、Grep、LS）を使用してコードベースを分析
4. 新規ファイルの場合: 包括的な初期ドキュメントを生成
5. 既存ファイルの場合: 
   - まず現在のコンテンツを読む
   - ユーザーカスタマイズとコメントを保持
   - 事実/技術情報のみを更新
   - 既存の構造とスタイルを維持
6. 適切なヘッダーとセクションで明確なマークダウンフォーマットを使用
7. 理解に役立つ場所で具体的な例を含める
8. 推測より事実に焦点 - 存在するものを文書化
9. 仕様駆動開発の原則に従う

## 重要な原則

### セキュリティガイドライン

- 機密データを含めない: APIキー、パスワード、データベース認証情報、個人情報は含めない
- コミット前にレビュー: バージョン管理前に常にステアリングコンテンツをレビュー
- チーム共有の考慮: ステアリングファイルはすべてのプロジェクトコラボレーターと共有されることを覚えておく

### コンテンツ品質ガイドライン

- 単一ドメインフォーカス: 各ステアリングファイルは1つの特定領域をカバーすべき
- 明確で説明的なコンテンツ: 具体的な例と決定の根拠を提供
- 定期メンテナンス: 主要なプロジェクト変更後にステアリングファイルをレビューと更新
- 実行可能なガイダンス: 抽象的な原則よりも、具体的で実装可能なガイドラインを記載

### 保存戦略

- ユーザーセクション: 標準テンプレートにないセクションは保持されるべき
- カスタム例: ユーザー追加の例は維持されるべき
- コメント: インラインコメントやノートは保持されるべき
- フォーマット設定: 既存のマークダウンスタイルの選択を尊重

### 更新哲学

- デフォルトで追加: 置き換えではなく新しい情報を追加
- 非推奨をマーク: 取り消し線または[DEPRECATED]タグを使用
- 重要な変更に日付を追加: 大きな変更に更新タイムスタンプを追加
- 変更を説明: 何かが更新された理由の簡単なメモ

ユーザーカスタマイズを尊重しながら現在の状態を維持し、ユーザーが作業を失う心配なく効果的な仕様駆動開発をサポートする生きたドキュメントの維持が目標です。
ultrathink
