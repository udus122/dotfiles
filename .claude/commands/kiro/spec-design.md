---
description: 仕様の技術設計を作成
allowed-tools: Bash, Read, Write, Edit, MultiEdit, Update, WebSearch, WebFetch
---

# 技術設計

機能の包括的な技術設計を作成: $ARGUMENTS

## インタラクティブ承認: 要件レビュー

重要: 設計は要件がレビューおよび承認された後にのみ生成可能です。

### 要件レビュープロセス

- 要件ドキュメント: @.kiro/specs/$ARGUMENTS/requirements.md
- 仕様メタデータ: @.kiro/specs/$ARGUMENTS/spec.json

インタラクティブ承認プロセス:
1. 要件の存在確認 - requirements.mdが生成されていることを確認
2. 人間によるレビューの促進 - ユーザーに質問: "requirements.mdをレビューしましたか？ [y/N]"
3. 'y' (はい)の場合: spec.jsonを自動的に更新して要件を承認し、設計生成を続行
4. 'N' (いいえ)の場合: 実行を停止し、まずrequirements.mdをレビューするよう指示

ユーザーがレビューを確認した際のspec.json自動承認更新:
```json
{
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true  // ← ユーザーが確認時に自動的にtrueに設定
    }
  },
  "phase": "requirements-approved"
}
```

ユーザーインタラクション例:
```
📋 設計生成前に要件レビューが必要です。
📄 レビューしてください: .kiro/specs/feature-name/requirements.md
❓ requirements.mdをレビューしましたか？ [y/N]: y
✅ 要件が自動的に承認されました。設計生成を続行します...
```

## コンテキスト分析

### 要件の基盤

重要: 設計は承認された要件ドキュメントに基づいて構築される必要があります。

- 要件ドキュメント: @.kiro/specs/$ARGUMENTS/requirements.md
- EARS形式の要件: 各要件と受け入れ基準
- ユーザーストーリーのマッピング: 設計コンポーネントは特定のユーザーストーリーに対応する必要がある
- 制約と受け入れ基準: 技術的決定に反映される必要がある

確認必須: 続行する前にrequirements.mdが存在し、承認されていることを確認してください。

### ステアリングコンテキスト

- 現在のアーキテクチャ: @.kiro/steering/structure.md
- 技術スタック: @.kiro/steering/tech.md
- プロダクト制約: @.kiro/steering/product.md

### 現在の仕様コンテキスト

- 現在の設計: @.kiro/specs/$ARGUMENTS/design.md
- 仕様メタデータ: @.kiro/specs/$ARGUMENTS/spec.json

## タスク: 技術設計の作成

前提条件の確認済み: 要件が承認され、設計フェーズの準備が完了しています。

### 調査とリサーチプロセス

必須: 設計プロセス中に調査とリサーチを実施:

1. 技術調査
   - 技術スタックの現在のベストプラクティスを調査
   - セキュリティの考慮事項と最新標準を調査
   - パフォーマンスベンチマークとスケーリングアプローチをレビュー
   - 既存アーキテクチャとの統合パターンを検証

2. コンテキスト構築
   - 会話スレッドで調査コンテキストを構築
   - 設計決定に影響を与える重要な発見を文書化
   - ソースを引用し、参照用の関連リンクを含める
   - アーキテクチャの選択に影響を与える洞察を要約

3. 要件分析
   - 各設計コンポーネントを特定のEARS要件にマッピング
   - すべてのユーザーストーリーが技術設計で対処されていることを確認
   - 提案されたソリューションで受け入れ基準を満たせることを検証
   - 要件と技術的実現可能性のギャップを特定

### 設計ドキュメント生成

spec.jsonで指定された言語で、調査結果を組み込んだ包括的な設計ドキュメントを生成:

### 1. 設計ドキュメント構造
spec.jsonで指定された言語でdesign.mdを作成（「language」フィールドは`@.kiro/specs/$ARGUMENTS/spec.json`で確認）:

```markdown
# 技術設計

## 概要
[requirements.mdの主要な要件を参照しながら、実装アプローチの技術的概要]

## 要件マッピング

### 設計コンポーネントのトレーサビリティ

各設計コンポーネントは特定の要件に対応:
- [コンポーネント1] → REQ-X.X: [EARS要件参照]
- [コンポーネント2] → REQ-Y.Y: [EARS要件参照]
- [統合レイヤー] → REQ-Z.Z: [EARS要件参照]

### ユーザーストーリーカバレッジ

[requirements.mdのすべてのユーザーストーリーが対処されていることを確認]
- ユーザーストーリー1: [設計がこのストーリーにどう対応するか]
- ユーザーストーリー2: [このストーリーの技術的アプローチ]

## アーキテクチャ

[高レベルのシステムアーキテクチャと技術決定]

```mermaid
graph TB
    A[フロントエンドレイヤー] --> B[APIゲートウェイ]
    B --> C[ビジネスロジック]
    C --> D[データレイヤー]
    D --> E[データベース]
```

### 技術スタック

[調査結果と要件分析に基づく]

- フロントエンド: [React/Vue/Next.js] + [TypeScript]
- バックエンド: [FastAPI/Express/Django] + [言語] 
- データベース: [PostgreSQL/MySQL/MongoDB]
- 認証: [JWT/OAuth/Auth0]
- テスト: [Jest/pytest] + [Testing Library/Playwright]
- デプロイメント: [Docker/Vercel/AWS]

### アーキテクチャ決定の根拠

[調査に基づく主要な技術選択の理由を文書化]

- なぜ[フロントエンドフレームワーク]: [調査に基づく正当化]
- なぜ[バックエンド技術]: [パフォーマンス、スケーラビリティ、チームの専門知識の考慮]
- なぜ[データベース選択]: [データモデル要件、一貫性のニーズ、スケーリングパターン]
- なぜ[認証方法]: [セキュリティ要件、統合機能、ユーザーエクスペリエンス]

## データフロー

[システムを通じてデータがどのように流れるかの説明]

### 主要なユーザーフロー

トップ1-3のユーザーフローのシーケンス図を含む:

```mermaid
sequenceDiagram
    participant ユーザー
    participant フロントエンド
    participant API
    participant DB
    
    ユーザー->>フロントエンド: アクション
    フロントエンド->>API: リクエスト
    API->>DB: クエリ
    DB-->>API: 結果
    API-->>フロントエンド: レスポンス
    フロントエンド-->>ユーザー: UI更新
```

## コンポーネントとインターフェース

包括的なコンポーネントの内訳を生成。

### バックエンドサービスとメソッドシグネチャ

要件で特定された各サービスについて、簡潔なドキュメント文字列を含むパブリックメソッドをリスト。例（Python）:
```python
class InvoiceService:
    def create_invoice(self, data: InvoiceData) -> Invoice:  # 作成と永続化
    def send_invoice(self, invoice_id: str) -> None          # メール送信
```

### フロントエンドコンポーネント

テーブルを提供: コンポーネント名 │ 責任 │ Props/state概要。

### APIエンドポイント

詳細なAPIエンドポイントテーブルを提供:

| メソッド | ルート | 目的 | 認証 | ステータスコード |
| GET    | /api/[リソース] | リソース一覧 | 必須 | 200, 401, 500 |
| POST   | /api/[リソース] | リソース作成 | 必須 | 201, 400, 401, 500 |
| PUT    | /api/[リソース]/:id | リソース更新 | 必須 | 200, 400, 401, 404, 500 |
| DELETE | /api/[リソース]/:id | リソース削除 | 必須 | 204, 401, 404, 500 |

## データモデル

### ドメインエンティティ

1. [エンティティ1]: [簡潔な説明]
2. [エンティティ2]: [簡潔な説明]
3. [エンティティ3]: [簡潔な説明]

### エンティティ関係

```mermaid
erDiagram
    USER ||--o{ PROJECT : "所有"
    PROJECT ||--|{ TASK : "含む"
    USER ||--o{ TASK : "作成"
```

### データモデル定義

言語固有のモデルを提供（TypeScriptインターフェースおよび/またはPythonデータクラス）:

```typescript
interface [モデル名] {
  id: string;
  // 要件に基づいて関連フィールドを追加
  createdAt: Date;
  updatedAt: Date;
}
```

```python
@dataclass
class [モデル名]:
    id: str
    # 要件に基づいて関連フィールドを追加
    created_at: datetime
    updated_at: datetime
```

### データベーススキーマ

[SQLスキーマまたはNoSQLドキュメント構造]

### マイグレーション戦略

- スキーマ変更のマイグレーションアプローチ
- 後方互換性の考慮事項
- データ変換要件
- パフォーマンスのためのインデックス戦略

## エラーハンドリング

[包括的なエラーハンドリング戦略]

## セキュリティ考慮事項

### 認証と認可

- シーケンス図を含む認証フロー（JWT/OAuth）
- 認可マトリックス（ロールと権限）
- セッション管理戦略

### データ保護

- 入力検証アプローチ
- 保存時および転送時のデータ暗号化
- 機密データの取り扱い

### セキュリティベストプラクティス

- OWASP Top 10の軽減戦略
- APIレート制限
- CORS設定
- セキュリティヘッダーの実装

## パフォーマンスとスケーラビリティ

### パフォーマンス目標

| メトリック | 目標 | 測定方法 |
|--------|--------|-------------|
| レスポンス時間 (p95) | < 200ms | APIエンドポイント |
| レスポンス時間 (p99) | < 500ms | APIエンドポイント |
| スループット | > 1000 req/sec | 負荷テスト |
| データベースクエリ (p99) | < 50ms | クエリ監視 |
| 同時ユーザー数 | > 10,000 | システム容量 |

### キャッシング戦略

- ブラウザキャッシュ: 静的アセット、APIレスポンス
- CDN: メディアファイル、静的コンテンツ
- アプリケーションキャッシュ: セッションデータ用のRedis/Memcached
- データベースキャッシュ: クエリ結果のキャッシング

### スケーラビリティアプローチ

- アプリケーションサーバーの水平スケーリング
- データベースの読み取りレプリカ
- 非同期処理用のバックグラウンドジョブキュー
- 負荷メトリクスに基づく自動スケーリング


## テスト戦略

### テストカバレッジ要件
- ユニットテスト: ≥80%のコードカバレッジ
- 統合テスト: すべてのAPIエンドポイントと外部統合
- E2Eテスト: 重要なユーザージャーニー
- パフォーマンステスト: 予想ピークの2倍での負荷テスト

### テストアプローチ
1. ユニットテスト
   - 個々の関数とメソッドをテスト
   - 外部依存関係をモック
   - ビジネスロジックに焦点

2. 統合テスト
   - APIコントラクトテスト
   - データベース統合テスト
   - 外部サービス統合テスト

3. エンドツーエンドテスト
   - ユーザー認証フロー
   - コア機能ワークフロー
   - クロスブラウザ互換性

4. パフォーマンステスト
   - k6または類似ツールでの負荷テスト
   - システム限界のストレステスト
   - メモリリークの耐久テスト

### CI/CDパイプライン
```mermaid
graph LR
    A[コードプッシュ] --> B[リントとフォーマット]
    B --> C[ユニットテスト]
    C --> D[統合テスト]
    D --> E[ビルド]
    E --> F[E2Eテスト]
    F --> G[ステージングへデプロイ]
    G --> H[パフォーマンステスト]
    H --> I[本番へデプロイ]
```

```

### 2. ドキュメント生成
設計ドキュメントの内容のみを生成します。実際のドキュメントファイルにレビューや承認の指示を含めないでください。

### 3. メタデータの更新
spec.jsonを以下で更新:
```json
{
  "phase": "design-generated",
  "approvals": {
    "requirements": {
      "generated": true,
      "approved": true
    },
    "design": {
      "generated": true,
      "approved": false
    }
  },
  "updated_at": "現在のタイムスタンプ"
}
```

---

## インタラクティブ承認の実装（ドキュメントには含まれません）

以下はClaude Codeの会話専用 - 生成されたドキュメントには含まれません:

### インタラクティブ承認プロセス
このコマンドはインタラクティブ承認を実装:

1. 要件レビュープロンプト: ユーザーに要件レビューの確認を自動的に促す
2. 自動承認: ユーザーが'y'で確認するとspec.jsonを自動的に更新
3. 設計生成: 承認後すぐに続行
4. 次のフェーズ: 設計が生成され、`/kiro:spec-tasks`によるインタラクティブ承認の準備完了

### 次のフェーズのための設計レビュー
design.md生成後、次のフェーズ（`/kiro:spec-tasks $ARGUMENTS`）は同様のインタラクティブ承認を使用:

次のインタラクションのプレビュー:
```
📋 タスク生成前に設計レビューが必要です。
📄 レビューしてください: .kiro/specs/feature-name/design.md
❓ design.mdをレビューしましたか？ [y/N]: 
```

### レビューチェックリスト（ユーザー参照用）:
- [ ] 技術設計が包括的で明確
- [ ] アーキテクチャが既存システムと整合
- [ ] 技術選択が適切
- [ ] コンポーネントとインターフェースが明確に定義されている
- [ ] セキュリティとパフォーマンスの考慮事項が対処されている

## 指示事項

1. 要件の基盤を確認 - requirements.mdが存在し、承認されていることを確認
2. spec.jsonで言語を確認 - メタデータで指定された言語を使用
3. 包括的な調査を実施:
   - 技術のベストプラクティスと最新標準を調査
   - セキュリティ、パフォーマンス、統合の考慮事項を調査
   - 会話スレッドでの調査結果を通じてコンテキストを構築
   - 設計決定に影響を与えるソースと主要な洞察を文書化
4. 要件を徹底的に分析:
   - 各設計コンポーネントを特定のEARS要件にマッピング
   - すべてのユーザーストーリーが技術設計で対処されていることを確認
   - 提案されたソリューションで受け入れ基準を満たせることを検証
5. ステアリングコンテキストから既存のアーキテクチャパターンに従う
6. 論理的な順序でドキュメントを構成:
   - 概要 → 調査とコンテキスト → 要件マッピング → アーキテクチャ → データフロー → コンポーネント → データモデル → エラーハンドリング → セキュリティ → パフォーマンス → テスト
7. 明確なインターフェースとAPI仕様を含む詳細なコンポーネント設計を作成
8. アーキテクチャ、データフロー、ERダイアグラムにmermaidを使用した包括的な図を含める
9. 設計根拠を文書化 - 主要な技術的決定の理由を説明
10. 具体的なパフォーマンス目標とテスト戦略を定義
11. 完了時にトラッキングメタデータを更新

徹底的な調査と明示的な要件トレーサビリティに基づき、スケーラビリティ、セキュリティ、保守性を適切に考慮した、実装フェーズのための明確な設計図を生成します。
ultrathink
